
版本V1
  
	该程序 消费模式有三种
		1
			内销模式 ：（推荐实用环境 ： 消息的生命末端 ，消息的处理  。当不满足需求的情况下 自定义实现消费  。 可调用其他模式消费 ）
			
				该模式下  只需要继承  baseMessageListenerConsumer  接口 实现该接口的方法 即可  
				
				和使用 官方MQ一样 只是对其进行了包装拓展   对实体数据进行了 编码转换，和容错次数验证 
				
		2  
			外调模式 ：（推荐使用环境 ： 业务特殊，个别客户特殊处理   或  有需要动态拓展需求 ）
			
				该模式是为了 将其调用 其他 服务 （ SOA 理念 和 restful api 理念 ） 
				
			 	该模式的核心理念就是    高拓展性  低耦合度  高并发
				
			   	通过MQ消费端的 N线程消费，和 web服务器的 N请求处理的特性   结合实现一套 高并发的  消息处理模式。 	
				
				SOA（面向服务）和 restful api （一切都是资源） 非常建议 符合 改理念来编写 被调用 WEB服务端
				
				支持N个 Web服务端 调用  但是  只要一个调用失败 将不再执行后续 调用 并且 从新开始消费  
				（不建议 指定多个 Topic 外调）
								
				//TODO 后续将加入验证规则调用对应的    Web服务端
		3 
			转发模式 ：（推荐使用环境 ： 高并发，超大数据量处理节点  通过简单匹配 进行动态分流 ）
			
				该模式 支持 Tags 和  实体  数据信息  匹配   定义转发的队列 名称和 标签
				
				支持 N个转发对象和验证  但是  只要一个 转发失败 将不再 执行后续转发 并且 从新开始消费
			        （不建议 指定多个 Topic 转发）
				
	使用理念：
			内销模式  建议使用场景为 消息生命末端     也就是对消息的最后的处理 。
			
			外调模式  建议使用场景为  处理非主流业务或满足特殊客户的特性需求 进行的 定制拓展 
			
			通过内销模式  可以和其他的结合  因为内销情况下  需要手动编写代码    完全由自己控制
			
	总结：
		     对阿里MQ 进行包装 是想通过 改MQ 来实现一套 动态管理消费端，轻易可拓展 ，轻易可使用的  分布式微服务程序 。
		     				 

版本V2
	
	新增：
		1	MQ在一个集群中 只能消费 一个 topic 下 一个 Tags 的 页面提示 
	
版本V3

	新增：
		
		1	外调模式  验证规则 匹配 调用 对应的 Web服务端
	  
		2   转发模式 和  外调模式 中 增加 对 消息实体的 数据转译 处理接口
	  
版本V3.0.1
	
	修改了  验证方法 Bug
	  
	  


问题备注：
      如 HTML 页面 报错 跨域问题， 请删除  maven 库  spring 4.2 版本 重新获取	  
		